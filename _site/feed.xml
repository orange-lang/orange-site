<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Orange</title>
    <description>Orange Programming Language</description>
    <link>http://orange-lang.org/</link>
    <atom:link href="http://orange-lang.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 29 Dec 2015 14:08:13 -0500</pubDate>
    <lastBuildDate>Tue, 29 Dec 2015 14:08:13 -0500</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Defining Orange</title>
        <description>&lt;p&gt;After completing a
&lt;a href=&quot;https://github.com/orange-lang/orange/pull/21&quot;&gt;second full rewrite&lt;/a&gt; of the
compiler, defining what kind of language Orange will be has still been a
struggle.&lt;/p&gt;

&lt;p&gt;Currently, Orange sits around 20K lines of code: a mix between C++ and tests
written in Orange itself. Working with a decent chunk of C++ code for Orange
and C# at work has continued to
&lt;a href=&quot;https://github.com/orange-lang/orange/issues/24&quot;&gt;inspire&lt;/a&gt;
&lt;a href=&quot;https://github.com/orange-lang/orange/issues/15&quot;&gt;me&lt;/a&gt; as to what kind of
workflow I’d like to see possible with the language.&lt;/p&gt;

&lt;p&gt;There are a few features that I’m considering a must for Orange:
	- Optional non-tracing garbage collection
	- Object Orientation
	- Reflection
	- Package Management and other Utilities&lt;/p&gt;

&lt;h1 id=&quot;optional-non-tracing-garbage-collection&quot;&gt;Optional non-tracing garbage collection&lt;/h1&gt;

&lt;p&gt;C++’s &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; approach to a reference-counting garbage collection
system is handy, but a giant pain to use. Orange’s garbage collection
will work more similarly to Apple’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Automatic_Reference_Counting&quot;&gt;Automatic Reference Counting&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If possible, Orange will automatically insert code to release objects at
compile-time to avoid unnecessary run-time checks of reference counts.&lt;/p&gt;

&lt;p&gt;Orange will still allow this feature to be disabled, being replaced with manual
&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt; calls when manually managing memory is important.&lt;/p&gt;

&lt;h1 id=&quot;object-orientation&quot;&gt;Object Orientation&lt;/h1&gt;

&lt;p&gt;Support for classes is currently being developed in my
&lt;a href=&quot;https://github.com/rfratto/orange/tree/classes&quot;&gt;personal fork&lt;/a&gt; of Orange, and
is on its way in.&lt;/p&gt;

&lt;p&gt;Orange &lt;em&gt;is&lt;/em&gt; multi-paradigm so imperative programming can
still be used above OOP, but similarly to C++, giving the choice is important.&lt;/p&gt;

&lt;h1 id=&quot;reflection&quot;&gt;Reflection&lt;/h1&gt;

&lt;p&gt;The necessity of reflection is a hot topic amongst programmers, but I believe
that it can be an extremely useful tool for certain systems like unit tests
or other dynamic environments. Support for reflection will
be built into the runtime type information of Orange, and can be disabled,
similarly to gcc/clang’s &lt;code class=&quot;highlighter-rouge&quot;&gt;-fno-rrti&lt;/code&gt; flag.&lt;/p&gt;

&lt;h1 id=&quot;package-management-and-other-utilities&quot;&gt;Package Management and other Utilities&lt;/h1&gt;

&lt;p&gt;As (currently) the sole maintainer of Orange, I can’t reasonably include
everything into the standard library on my own. C++, after 30 years, still
doesn’t have package management. Any modern programming language should have
package management built in.&lt;/p&gt;

&lt;p&gt;Orange will support globally installing packages and installing packages
locally to a project, where the project definition file (&lt;code class=&quot;highlighter-rouge&quot;&gt;orange.settings.json&lt;/code&gt;)
will define the dependencies of the language. It should be able to grab
dependencies straight from Github or a package directory service.&lt;/p&gt;

&lt;p&gt;Just being able to call &lt;code class=&quot;highlighter-rouge&quot;&gt;orange install mylibrary&lt;/code&gt; isn’t enough for a compiler
command line interface: other tools, such as code formatters, project creation,
code-completion interfaces, package uploading, and testing should be built into
the binary, and so it will.&lt;/p&gt;

&lt;h1 id=&quot;defining-orange&quot;&gt;Defining Orange&lt;/h1&gt;

&lt;p&gt;Orange is a portable, compiled, statically typed, multi-paradigm (imperative,
object-oriented, reflective) systems programming language with focus on high
productivity, features for DRY code, and a smooth syntax without sacrificing
efficiency.&lt;/p&gt;

&lt;h1 id=&quot;discuss&quot;&gt;Discuss&lt;/h1&gt;

&lt;p&gt;Disagree with anything in this post, or have any ideas? Feel free to comment
in the Disqus module below, our IRC channel
&lt;a href=&quot;http://webchat.freenode.net/?channels=%23orange-lang&quot;&gt;#orange-lang&lt;/a&gt; on
irc.freenode.net, or
&lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/orange-lang&quot;&gt;Google Group&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Dec 2015 00:00:00 -0500</pubDate>
        <link>http://orange-lang.org/blog/2015/12/29/defining-orange.html</link>
        <guid isPermaLink="true">http://orange-lang.org/blog/2015/12/29/defining-orange.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Hello, world!</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extern printf(char *s, ...) -&amp;gt; int32 
printf(&quot;Hello, world!\n&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Orange is a new language that’s still in heavy development. As you can see from the example above, 
you have to link against C functions right now to create any “real” code.&lt;/p&gt;

&lt;h2 id=&quot;present-orange&quot;&gt;Present Orange&lt;/h2&gt;

&lt;p&gt;Let’s look at a more complicated example than our hello world:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extern printf(char* s, ...) -&amp;gt; int32

# increment all elements in an array by 1 
# arr: the array to increment 
# sz: the size of the array
def inc(var arr, var sz) 
	arr[i]++ for (var i = 0; i &amp;lt; sz; i++)
end 

# declare variables with var
var arr = [5, 3, 2, 3, 6]

# ... or with literal types!
int arr_sz = sizeof(arr)/sizeof(int) 

inc(arr, arr_sz) 

for (var i = 0; i &amp;lt; arr_sz; i++) 
	printf(&quot;%d\n&quot;, arr[i])
end 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You may be able to tell that’s it’s very C-like, in some ways: arrays are just pointers, so 
they’re pass-by-reference, and &lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt; exists for you to get the size of data primitives.&lt;/p&gt;

&lt;p&gt;You may wonder what’s the significance of &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; in the function header of &lt;code class=&quot;highlighter-rouge&quot;&gt;inc&lt;/code&gt;. Well, if 
a function has a parameter whose type is &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;, then that parameter is a generic, and so is 
the function. With generics, a unique function is created for each of the parameters that’s 
passed in.&lt;/p&gt;

&lt;p&gt;Orange didn’t always look this way, however. A few weeks ago, this would’ve been the syntax:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extern printf(char* s, ...) -&amp;gt; int32 

def inc(arr, sz)
	arr[i]++ for (i = 0; i &amp;lt; sz; i++)
end

arr = [5, 3, 2, 3, 6]
arr_sz = sizeof(arr)/sizeof(int)

inc(arr, arr_sz)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In terms of typing, it is indeed more simple, but it allowed for a lot of errors, since if 
you reassign a value to a variable and mistype its name, it would just create a new variable. 
Try tracking that one down!&lt;/p&gt;

&lt;h2 id=&quot;future-of-orange&quot;&gt;Future of Orange&lt;/h2&gt;

&lt;p&gt;Orange has come quite a ways since its inception in December 2014. It’s nowhere near a 1.0 release, 
but it’s shaping up to be one hell of a langauge. It does bring up the question about how the 
high-level features will work.&lt;/p&gt;

&lt;p&gt;Here’s an example of what’s in the pipeline for something like concurrency:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SomeClass 
	int num = 0
end 

def randomizeNum(var myObj, var times)
	for (var i in [0..times])
		# no need for -&amp;gt; in Orange 
		myObj.num = Math.rand()

		sleep(1)

		# Send it to a channel, if one is registered 
		# channels are buffered: writing is non-blocking 
		send myObj.num
	end 
end

var myObj = new SomeClass
var times = 20 

# call randomizeNum concurrently 
# write results to channel named chan 
do randomizeNum(myObj, times) -&amp;gt; chan 

# let&#39;s only get half of our random numbers
for (var i in [0..times/2]) 
	# get a number from chan, waiting until 
	# one is available 
	var num &amp;lt;- chan 
	print(&quot;Random number: #{num}&quot;)
end 

# chans are aware of threads; wait for 
# randomizeNum to finish
wait chan 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 06 Jul 2015 14:32:57 -0400</pubDate>
        <link>http://orange-lang.org/blog/2015/07/06/hello-world.html</link>
        <guid isPermaLink="true">http://orange-lang.org/blog/2015/07/06/hello-world.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
